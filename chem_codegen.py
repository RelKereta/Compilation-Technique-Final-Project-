# chem_codegen.py - Code Generation Stage (Final Compiler Stage)
"""
Code Generator for Chemical Reaction Compiler

This module implements the final stage of the compilation pipeline:
generating executable code from the validated AST.

Compilation Stages:
1. Lexical Analysis (chem_lexer.py)
2. Syntax Analysis (chem_parser.py)
3. Semantic Analysis (chem_semantics.py)
4. Code Generation (THIS FILE) â† Final Stage
"""

from chem_parser import Reaction, Molecule
from typing import Dict, List, Tuple
import math

class CodeGenerator:
    """
    Generates executable code from validated chemical reactions.
    
    Output Formats:
    1. Python code representation
    2. Balanced equation with coefficients
    3. Stoichiometry calculator
    4. Intermediate representation (IR)
    """
    
    def __init__(self):
        self.output_code = []
        self.ir_code = []  # Intermediate Representation
        
    def generate(self, reaction: Reaction) -> Dict[str, str]:
        """
        Main code generation method.
        
        Args:
            reaction: Validated Reaction object from parser
            
        Returns:
            Dictionary containing different code outputs:
            - 'python': Python code representation
            - 'balanced': Balanced equation string
            - 'ir': Intermediate representation
            - 'calculator': Stoichiometry calculator code
        """
        outputs = {}
        
        # 1. Generate Python Code
        outputs['python'] = self.generate_python_code(reaction)
        
        # 2. Generate Balanced Equation
        outputs['balanced'] = self.generate_balanced_equation(reaction)
        
        # 3. Generate Intermediate Representation
        outputs['ir'] = self.generate_ir(reaction)
        
        # 4. Generate Stoichiometry Calculator
        outputs['calculator'] = self.generate_calculator_code(reaction)
        
        # 5. Generate Assembly-like Code (for demonstration)
        outputs['assembly'] = self.generate_assembly(reaction)
        
        return outputs
    
    def generate_python_code(self, reaction: Reaction) -> str:
        """Generate executable Python code for the reaction."""
        code = []
        code.append("# Generated Python Code for Chemical Reaction")
        code.append("# Auto-generated by Chemical Reaction Compiler\n")
        code.append("from collections import defaultdict\n")
        
        # Define Molecule class
        code.append("class Molecule:")
        code.append("    def __init__(self, formula, elements):")
        code.append("        self.formula = formula")
        code.append("        self.elements = elements  # Dict[str, int]")
        code.append("    ")
        code.append("    def __repr__(self):")
        code.append("        return self.formula\n")
        
        # Define reactants
        code.append("# Reactants")
        for i, mol in enumerate(reaction.reactants):
            elements_dict = self._molecule_to_dict(mol)
            code.append(f"reactant_{i+1} = Molecule('{mol}', {elements_dict})")
        
        code.append(f"reactants = [{', '.join(f'reactant_{i+1}' for i in range(len(reaction.reactants)))}]\n")
        
        # Define products
        if reaction.products:
            code.append("# Products")
            for i, mol in enumerate(reaction.products):
                elements_dict = self._molecule_to_dict(mol)
                code.append(f"product_{i+1} = Molecule('{mol}', {elements_dict})")
            
            code.append(f"products = [{', '.join(f'product_{i+1}' for i in range(len(reaction.products)))}]\n")
        else:
            code.append("# Products (to be predicted)")
            code.append("products = []\n")
        
        # Generate reaction equation
        reactants_str = ' + '.join(str(m) for m in reaction.reactants)
        products_str = ' + '.join(str(m) for m in reaction.products) if reaction.products else '?'
        code.append(f"# Reaction: {reactants_str} -> {products_str}")
        code.append(f"reaction_equation = '{reactants_str} -> {products_str}'")
        code.append("print(f'Reaction: {{reaction_equation}}')")
        
        return '\n'.join(code)
    
    def generate_balanced_equation(self, reaction: Reaction) -> str:
        """
        Generate balanced chemical equation with coefficients.
        Uses simple balancing algorithm for common reaction types.
        """
        if not reaction.products:
            return f"{' + '.join(str(m) for m in reaction.reactants)} -> ?"
        
        # Simple balancing for demonstration
        # In a real compiler, this would use matrix methods or algebraic balancing
        coefficients_reactants = [1] * len(reaction.reactants)
        coefficients_products = [1] * len(reaction.products)
        
        # Try to balance (simplified algorithm)
        balanced = self._attempt_balance(reaction, coefficients_reactants, coefficients_products)
        
        if balanced:
            coeffs_r, coeffs_p = balanced
            reactants_str = ' + '.join(
                f"{c if c > 1 else ''}{m}" 
                for c, m in zip(coeffs_r, reaction.reactants)
            )
            products_str = ' + '.join(
                f"{c if c > 1 else ''}{m}" 
                for c, m in zip(coeffs_p, reaction.products)
            )
            return f"{reactants_str} -> {products_str}"
        
        # If balancing fails, return unbalanced
        return f"{' + '.join(str(m) for m in reaction.reactants)} -> {' + '.join(str(m) for m in reaction.products)}"
    
    def generate_ir(self, reaction: Reaction) -> str:
        """
        Generate Intermediate Representation (IR) code.
        Similar to LLVM IR or three-address code.
        """
        ir = []
        ir.append("; Chemical Reaction Intermediate Representation")
        ir.append("; Three-Address Code Format\n")
        
        # Declare reactants
        for i, mol in enumerate(reaction.reactants):
            ir.append(f"%reactant{i+1} = MOLECULE \"{mol}\"")
            for symbol, count in mol.elements:
                ir.append(f"  ELEMENT %reactant{i+1}, \"{symbol}\", {count}")
        
        ir.append("")
        
        # Declare products
        if reaction.products:
            for i, mol in enumerate(reaction.products):
                ir.append(f"%product{i+1} = MOLECULE \"{mol}\"")
                for symbol, count in mol.elements:
                    ir.append(f"  ELEMENT %product{i+1}, \"{symbol}\", {count}")
        
        ir.append("")
        
        # Reaction operation
        reactant_refs = ', '.join(f"%reactant{i+1}" for i in range(len(reaction.reactants)))
        if reaction.products:
            product_refs = ', '.join(f"%product{i+1}" for i in range(len(reaction.products)))
            ir.append(f"REACT [{reactant_refs}] -> [{product_refs}]")
        else:
            ir.append(f"REACT [{reactant_refs}] -> [UNKNOWN]")
        
        ir.append("\nRETURN %reaction")
        
        return '\n'.join(ir)
    
    def generate_calculator_code(self, reaction: Reaction) -> str:
        """Generate stoichiometry calculator code."""
        code = []
        code.append("# Stoichiometry Calculator")
        code.append("# Calculate moles and masses for this reaction\n")
        
        code.append("def calculate_stoichiometry(reactant_moles):")
        code.append("    '''")
        code.append(f"    Reaction: {reaction}")
        code.append("    '''")
        code.append("    results = {}")
        code.append("    ")
        code.append("    # Input: moles of reactants")
        reactants_list = ', '.join(f"'{m}': moles" for m in reaction.reactants)
        code.append(f"    # reactant_moles = {{{reactants_list}}}")
        code.append("    ")
        
        if reaction.products:
            code.append("    # Calculate product moles (1:1 ratio for simplicity)")
            for mol in reaction.products:
                code.append(f"    results['{mol}'] = reactant_moles.get('{reaction.reactants[0]}', 0)")
        
        code.append("    ")
        code.append("    return results")
        code.append("\n# Example usage:")
        code.append(f"# result = calculate_stoichiometry({{'{reaction.reactants[0]}': 1.0}})")
        code.append("# print(result)")
        
        return '\n'.join(code)
    
    def generate_assembly(self, reaction: Reaction) -> str:
        """Generate assembly-like code for demonstration."""
        asm = []
        asm.append("; Chemical Reaction Assembly Code")
        asm.append("; Pseudo-assembly for educational purposes\n")
        
        asm.append("section .data")
        for i, mol in enumerate(reaction.reactants):
            asm.append(f"    reactant{i+1} db '{mol}', 0")
        
        if reaction.products:
            for i, mol in enumerate(reaction.products):
                asm.append(f"    product{i+1} db '{mol}', 0")
        
        asm.append("\nsection .text")
        asm.append("    global _start\n")
        asm.append("_start:")
        asm.append("    ; Load reactants into registers")
        for i in range(len(reaction.reactants)):
            asm.append(f"    mov rax, reactant{i+1}")
        
        asm.append("    ")
        asm.append("    ; Perform reaction")
        asm.append("    call react")
        asm.append("    ")
        asm.append("    ; Store products")
        if reaction.products:
            for i in range(len(reaction.products)):
                asm.append(f"    mov rbx, product{i+1}")
        
        asm.append("    ")
        asm.append("    ; Exit")
        asm.append("    mov rax, 60")
        asm.append("    xor rdi, rdi")
        asm.append("    syscall")
        
        return '\n'.join(asm)
    
    def _molecule_to_dict(self, molecule: Molecule) -> Dict[str, int]:
        """Convert Molecule to dictionary representation."""
        result = {}
        for symbol, count in molecule.elements:
            if symbol in result:
                result[symbol] += count
            else:
                result[symbol] = count
        return result
    
    def _attempt_balance(self, reaction: Reaction, coeffs_r: List[int], coeffs_p: List[int]) -> Tuple[List[int], List[int]]:
        """
        Attempt to balance the equation.
        Returns (reactant_coefficients, product_coefficients) or None.
        
        This is a simplified balancing algorithm.
        A complete implementation would use matrix methods.
        """
        # For now, return 1:1 coefficients
        # A real implementation would solve the system of linear equations
        return (coeffs_r, coeffs_p)
    
    def optimize(self, code: str) -> str:
        """
        Optimize generated code (optional optimization pass).
        """
        # Simple optimizations:
        # - Remove redundant operations
        # - Combine similar operations
        # - Constant folding
        
        optimized = code
        
        # Remove empty lines (simple optimization)
        lines = [line for line in optimized.split('\n') if line.strip()]
        
        return '\n'.join(lines)
